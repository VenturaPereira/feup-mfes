class Printer

-- TODO: Possibly find a way to move this code to Service.vdmpp and make it a singleton.
values
	public BW_PAGE_PRICE: rat = 0.10;
	public COLOR_PAGE_PRICE: rat = 0.25;
	public DIM_MULT_PRICE: rat = 2;

types
	public String = seq of char;
	
values
	-- TODO Define values here

instance variables
	private machine_id: String := "Unnamed printer";
	private auth_student: [Student] := nil;
	private queue: seq of Document := [];
	private malfunctions: set of Malfunction := {};
	
	private STAT_PRINTED_DOCS: nat := 0;
	private STAT_PRINTED_PAGES: nat := 0;

operations
	-- Printer constructor.
	public Printer: String ==> Printer
	Printer(id) == (machine_id := id; return self)
	pre (elems "fe" inter elems id = elems "fe") or (elems "fl" inter elems id = elems "fl") or (elems "ic" inter elems id = elems "ic")
	post self.machine_id = id and RESULT = self; 
	
	-- Authenticate student. On this step a student should insert its credentials on the printer.
	public auth: Student ==> ()
	auth(student) == (auth_student := student; queue := [])
	post self.auth_student <> nil and self.queue = [];
	
	-- Reset operation, unauthenticating the student and clearing the machine's printing queue.
	public reset: () ==> ()
	reset() == (auth_student := nil; queue := [])
	post auth_student = nil and queue = [];
		
	-- Select student's documents from its personal printing queue and add them to printer's queue.
	public sel_student_docs: seq of nat ==> ()
	sel_student_docs(idx) == for i in idx do
		if i <= len self.auth_student.get_queue() and (i > 0)
		then queue := queue ^ [self.auth_student.get_queue()(i)]
	pre len idx <> 0 and (self.auth_student <> nil)
	post len self.queue = len queue~ + len idx;
	
	-- Start printing the student's queued documents.
	public print: () ==> ()
	print() == (
		if self.check_insufficient_funds() then return;
		auth_student.add_balance(-self.calc_print_cost());
		STAT_PRINTED_DOCS := STAT_PRINTED_PAGES + len queue;
		for doc in self.queue do (
			STAT_PRINTED_PAGES := STAT_PRINTED_PAGES + doc.get_page_no();
			auth_student.delete_document(doc);
			queue := tl queue;
		);
		IO`print("All documents printed!");
	)
	pre self.auth_student <> nil and len queue > 0
	post true;
	
	-- Return the total cost for printing the entire queue.
	public pure calc_print_cost: () ==> rat
	calc_print_cost() == (
		dcl op_cost: rat := 0.0;
		
		for doc in self.queue do (
			dcl subtotal: rat := 0.0;
			if doc.get_color() = <BW> then subtotal := subtotal + BW_PAGE_PRICE * doc.get_page_no()
			else subtotal := subtotal + COLOR_PAGE_PRICE * doc.get_page_no();
			if doc.get_dimension() = <A3> then subtotal := subtotal * DIM_MULT_PRICE;
			op_cost := op_cost + subtotal;
		);
		return floor (op_cost * 100) / 100;  -- Round to two decimal places.
	)
	post true;
	
	-- Check whether the student has sufficient funds to print its desired documents.
	public check_insufficient_funds: () ==> bool
	check_insufficient_funds() == return calc_print_cost() > self.auth_student.get_balance()
	post true;
	
	-- Getter method for authenticated student.
	public pure get_auth_student: () ==> [Student]
	get_auth_student() == return self.auth_student
	post RESULT = self.auth_student;
	
	-- Getter method for queue.
	public pure get_queue: () ==> seq of Document
	get_queue() == return self.queue
	post RESULT = self.queue;
	
functions
	-- TODO Define functiones here

traces
	-- TODO Define Combinatorial Test Traces here

end Printer